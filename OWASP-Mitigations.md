# Tasks for securing the web application

---

## Jason

---

### Cryptographic Failures

#### Implemented:
- When generating something random such as for session IDs, use a cryptographically secure random number generator (RNG).
  - Reasons:
    - RNG in computers can be a problem for sensitive actions such as for session identifier, cryptography operations, etc. as they can be very predictable. 
      - Hence, RNG in computers are commonly referred to as pseudo-RNG.
      - For example, JavaScript's Math.random() function is a pseudo-RNG that can be predicted.
        - References: [Don't Trust Computer Generated Random Numbers by PwnFunction](https://youtu.be/-h_rj2-HP2E)
    - Ensure that the randomly generated bytes/hex has high entropy.
  - Mitigations:
    - Using Python's [secrets module](https://docs.python.org/3/library/secrets.html#module-secrets)
      - Recommended by [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation) to ensure higher entropy
    - Using Google Cloud Platform Key Management Service's Cloud Hardware Security Module RNG API.

- Secure Flask Session Cookie
  - Using Google Cloud Platform KMS API RNG in the Cloud HSM (4096 bits)
    - Ensures high entropy
    - Unlikely to be guessed ($2^{4096}$ possible keys)
    - Prevent session cookie from being tampered with
    - Automatically rotated at the end of each month
    - In the event that the key is leaked, the key can be simply rotated using [Google Cloud Platform Secret Manager API](https://cloud.google.com/secret-manager)
  - Configured the default HMAC algorithm used from HMAC-SHA1 to HMAC-SHA512
    - Since SHA1 has been "broken" and is no longer considered secure, it is now recommended to use SHA256 or SHA512
    - References:
      - [SHATTERED](https://shattered.it/)
      - [OWASP](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/#how-to-prevent)

- [Argon2](https://pypi.org/project/argon2-cffi/) for hashing passwords
  - Argon2 will generate a random salt using `os.urandom(nBytes)` which is more secure than setting your own salt
  - Type used: Argon2id (A hybrid of Argon2i and Argon2d)
    - Argon2i is more resistant against [cache side-channel attacks](https://en.wikipedia.org/wiki/Side-channel_attack#cache_side-channel_attack)
    - Argon2d is more resistant against [GPU cracking attacks](https://security.stackexchange.com/questions/32816/why-are-gpus-so-good-at-cracking-passwords)
  - Minimum requirement as of [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html): 
    - 15MiB of memory
    - 2 count of iterations 
    - 1 degree of parallelism
  - Default Argon2 configuration (Meets the minimum requirements):
    - 64MiB of memory
    - 3 count of iterations
    - 4 degree of parallelism
    - 16 bytes salt, `os.urandom(16)`
    - 32 bytes hash
    - Argon2id
    - On average, the time taken to hash a password is about 0.05+ seconds.
  - Manually tweaked Argon2 configurations (Meets the minimum requirements):
    - 80MiB of memory
    - 6 count of iterations
    - 6 degrees of parallelism
    - 64 bytes salt, `os.urandom(64)`
    - 64 bytes hash
    - Argon2id
    - On average, the time taken to hash a password is about 0.5+ seconds.
- Using [Google OAuth2](https://developers.google.com/identity/protocols/oauth2/web-server) for login/signup (removed the need for storing passwords)

- Encrypting the (temporarily stored) sensitive data in the session cookie such as the state for Google OAuth2 logins
  - For layered security on top of HTTPS.
  - Using RSAES-OAEP 4096 bit key with a SHA-512 digest (Asymmetric Encryption)
    - 156 bits of security
  - Preventing sensitive data from being sniffed and exposed such as the session identifier
- Encrypting the sensitive data in the database using Google Cloud Platform KMS symmetric encryption service
  - Using Google Cloud Platform KMS (Key Management Service) API
  - 256-bit Advanced Encryption Standard (AES-256) keys in Galois Counter Mode (GCM), padded with Cloud KMS-internal metadata
  - Each user has a unique symmetric key for encryption and decryption
  - Encrypted the Argon2 hash of the password

- Removed the need of storing credit/debit card information with the implementation of stripe as the payment gateway

- Made an asymmetric signing function capable of JWT feature for authorising sensitive actions such as reset password
  - Digitally signed using Elliptic Curve P-384 key SHA384 Digest 
    - Using Google Cloud Platform KMS (Key Management Service) API
    - 192 bits of security

- Integrated Cloudflare to the custom domain, [coursefinity.social](https://coursefinity.social/)
  - Configured Cloudflare to redirect HTTP requests to use HTTPS
  - Enabled HTTP Strict Transport Security (HSTS) on Cloudflare
    - More secure than redirecting HTTP requests to HTTPS as the browser will know to automatically use HTTPS
      - Prevents man-in-the-middle attacks
    - More info on [OWASP cheatsheet series](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html)

---

### Identification and Authentication Failures

#### Implemented:
- IP address based authentication (Guard TOTP)
  - Idea inspired by [Steam Guard](https://help.steampowered.com/en/faqs/view/06B0-26E6-2CF8-254C)
  - Checks against known IP addresses of users against the login request
  - If the IP address is not known, the user will be asked to authenticate himself/herself using a generated 6 digit TOTP code that is sent to the user's email
  - The saved IP address will stay in the database until it has not been accessed on that IP address for more than 10 days

- 2 Factor Authentication using Google Authenticator Time-based OTP (TOTP)
  - Backup codes for the user to use to recover his/her account in the event his/her device is lost and is unable to retrieve the 2FA codes.
    - Recommended by [OWASP Multifactor Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html#resetting-mfa)
    - Will generate 8 sets of 8 bytes hexadecimal single-use codes and save them in the database
      - The stored codes in the database are encrypted using Google Cloud Platform KMS Symmetric Encryption/Decryption

- Implemented [reCAPTCHA Enterprise](https://cloud.google.com/recaptcha-enterprise) onto the web application
  - Added on:
    - Login page
    - Reset password request page
    - IP address based authentication (Guard TOTP) page
  - Prevent automated attacks such as
    - Credential stuffing attacks
    - Brute force attacks

- Minimum Password Complexity Policy using regex as recommended by [OWASP Authentication Cheatsheet](https://owasp.deteact.com/cheat/cheatsheets/Authentication_Cheat_Sheet.html#password-complexity)
  - At least 1 uppercase letter
  - At least 1 lowercase letter
  - At least 1 digit
  - At least 1 special character
  - At least 10 characters
  - Not more than 2 repeated characters
  - Requires user to match at least 3 of the above criteria
- Password strength meter to help users meet the password complexity policy
- Verification of passwords if the passwords has been leaked in the dark web using [haveibeenpwned's api](https://haveibeenpwned.com/API/)
  - Verified when:
    - After a successful login
    - Sign up
    - Changing password
    - Resetting password
  - If haveibeenpwned's API is unavailable, the password must match ALL the minimum password complexity policy criteria as a fallback

- Maximum of 6 failed login attempts per account (will reset after 1 hour)
  - In the event that the attacker tries to do a denial of service attack knowing that one could lock out authentic user:
    - An email will be sent to the user's email with a one-time link to unlock the account
    - Link uses a digitally signed token to prevent tampering

- Session Management Implementation:
  - Session identifier of 32 bytes (Unlikely to be guessed) stored in the database.
    - Ensured high entropy by using Google Cloud Platform Key Management Service (KMS) Cloud HSM's RNG API
  - Configured the session cookie to be deleted from the browser once the user closes the browser.
    - Initially, the session cookie will expire after 1 hour of inactivity (no requests to the web server).
    - However, it would be an inconvenience/bad usability as the web application is about watching educational videos which means that a user might not send a request to the web server for several minutes to possibly a few hours.
  - After 2 days in the database, the session identifier will be deleted.
    - To free up space in the database.
    - Attackers cannot reuse the session identifier and tamper with the cookie values as the cookie is digitally signed (HMAC-SHA512)
      - Although HMAC cannot be used for digital signature, in this context, it is possible as only the web application knows the secret key used in the HMAC algorithm.
  - Checks the session identifier in the database and compare with the session identifier in the cookie
  - Checks the user's digital fingerprint against the digital fingerprint in the database
    - Computes the SHA512 hash of the user's IP Address and user agent for the user's digital fingerprint for each request to the web application
      - If the user's digital fingerprint hash does not match the one in the database of the same session identifier, the user's session cookie will be cleared from their browser
    - Helps to prevent session hijacking via cookie theft
    - Idea inspired by [flask-paranoid](https://github.com/miguelgrinberg/flask-paranoid)
      - I did not use this library because it is not consistently maintained and it was easy to implement on top of my session management implementation
  - All mitigations above are aimed at mitigating the risk of session hijacking

- Using [Google OAuth2](https://developers.google.com/identity/protocols/oauth2/web-server) for authenticating users 
  - [More info on OAuth](https://owasp.org/www-pdf-archive/OWASP-NL_Chapter_Meeting201501015_OAuth_Jim_Manico.pdf)
  - Security of the login process will be handled by Google as the user has to sign in with Google

- Different method for logging in as an Admin (Using [Google OAuth2](https://developers.google.com/identity/protocols/oauth2/web-server))
  - Requires Google OAuth2 logins as identification and authentication will be handled by Google themselves which is more secure.
  - More secure as the admin does not use the same method of logging as normal users of the web application.
  - The admin routes are also IP address protected via a whitelist for extra security
    - Will retrieve the list of whitelisted IP addresses from Google Cloud Platform Secret Manager API for each request to the admin pages

- Securing the session cookie by setting the correct attributes such as HttpOnly, Secure, etc.
  - Secure:
    - Only allow the cookie to be transmitted via HTTPS
      - Prevent cookie from being sniffed and exposed
  - HttpOnly:
    - Prevent client-side scripts from accessing the cookie
      - Prevent cookie theft

---

## Eden

---

### Broken Access Control

#### Plan
- Make a admin only file 
  - Make a admin only files (such as a csv file of admin account info, user base info, etc.)
- Validate access (deny by default) such as for admin pages, etc. through the use of RBAC
- Deny request to a user's purchase course link
- Block all read and write access to SQL database except for the web app
- Work on integrating AWS Identity Provider with GCP Workforce Identification Pool
  - Since [google-sm.json](src/config_files/google-sm.json) is stored locally in the web file system, it is a security risk as one might get a copy and have access to all the secrets stored in Google Secret Manager API.
- Work on Admin console, a Super Administrator account must be created to access the admin console

#### Implemented:
- Role based Access Control which groups the approutes via Blueprints, access control is granted only to the specific blueprints group
- Role Based Access Control for the SQL Server
  - Removal of complex group based SQL based on teachers recommendations
  - This is due to the complexities of the group role functionality
  - Reduce the security of SQL server to CRUD and Execute, keeping security simple 
  - Security of SQL server depends on the web application to have proper Access Control

---

### Security Misconfiguration

#### Plan:
- Check if there's unnecessary features
- Showing too detailed error messages (such as in login pages)
- Check vulnerabilities in dependencies used
- Block users from access files outside of the web app
- Disallow default admin password such as "admin123"
- Ensure the web application has security in depth 
- Security features have to be layered 
- secure coding is practiced
- seperation of privileges
- application should fail safely
- Ensure RBAC are not hardcoded security constants

#### Sources:
- https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-123.pdf

#### Implemented:
- Seperation of user roles connecting to the mysql server
- Seperation of user role privileges in the mysql database
- Checked if Flask App.py uses default configuration
  - Currently we have set the cookies to be ONLY HTTPS 
  - Debug Mode must be disabled when application is set to Production

- Removal of any unused ports if any
  - Currently we are using port 8080 (web servers )
  - To communicate with users we use port 443 which is HTTPS only

- List of Files/Folders that must be disabled during production (due to possible attack surface)
  - For the sake of the technical review, they will be enabled
  - Folders that must be removed during production:
    - Sample files
    - Test files
  - Remove any Unused HTML,CSS Files

---

## Wei Ren

---

### Insecure Design

#### Plan:
- Flask limiter
- implement reCAPTCHA (if you have the time to read docs :D)
- Cloudflare!
- Fix errors
    - For insecure, you can allow user to buy nth num of a course
- Decide whether to use Flask login or the old style of session management

#### Implemented:
- Added [reCAPTCHA Enterprise](https://cloud.google.com/recaptcha-enterprise) on the signup page
- Configured Cloudflare to protect against DDoS attacks

---

### Security Logging and Monitoring Failures

#### Plan:
- Implement logging
- Log all logins (successful and failed logins), access controls (when user tries to access a folder, etc.), server-side input failures (SQL query, etc.)
- Implement an algorithm to detect malicious accounts (created in same IP, etc.)
- Ensure logs can be used by log management solution software
- Ensure logs is not vulnerable to corruption (multithreading :D, SQL injections, etc.)
- Prevent all access except read access to admins (need to create a log page for admins)
- Alert the security teams and/or admins in an event of a live attack (DDoS)

#### Implemented:
-

---

## Calvin

---

### Injection

#### Plan:
- Avoid Bad Coding Practices that lead to Injection Attacks
- Prevent SQL injections
- Remember to use multithreading for writing account info to the SQL database
- Protect against attacks via Markdown inputs (NOT MARKUP)

#### Implemented:
- SQL Injection
  - Implement Parameterised Queries
  - Implement Stored Procedures
- Server Side Template Injection
  - Avoid using render_template_string(template)
    - render_template() is safer because users are unable to modify the template
- Code / Command Injection
  - Avoid using eval()
  - Avoid using exec()
  - shell = False in subprocess_run()
- Cross Site Scripting
  - Avoid using render_template_string(template) [(Example)](https://semgrep.dev/r?q=python.flask.security.unescaped-template-extension.unescaped-template-extension)
  - In Jinja, everything is escaped by default except for values explicitly marked with the |safe filter.
    - If required use Markup()
  - Implemented CSP, but only for scripts & frames
    - Nonce-in only for inline scripts, those inline scripts without the nonce tags will not run properly
    - script src in csp shows all the scripts allowed to be taken from external sources
    - frame src in csp shows all the iframes allowed to be run

---

### Software and Data Integrity Failures

#### Plan:
- Implement hashing or digital signature whenever a user uploads something (User profile image, video upload for course creation, etc.)
- Fix deserialization vulnerability with pickle (shelve) by changing to SQL (You may have to do this first as we need to rely on you for the accounts)
- Ensure downloading/updating dependencies is not altered
    (check hash between original and downloaded files)

#### Implemented:
- Implemented MySQL
- Comparing Hashes of Packages, before pip installing them

---